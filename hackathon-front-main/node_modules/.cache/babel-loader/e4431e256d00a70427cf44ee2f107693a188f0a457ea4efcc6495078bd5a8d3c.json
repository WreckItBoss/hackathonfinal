{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst console_1 = require(\"console\");\nconst util_1 = __importDefault(require(\"util\"));\nconst session = __importStar(require(\"express-session\"));\nconst mongodb_1 = require(\"mongodb\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)('connect-mongo');\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\nconst unit = a => a;\nfunction defaultSerializeFunction(session) {\n  // Copy each property of the session to a new object\n  const obj = {};\n  let prop;\n  for (prop in session) {\n    if (prop === 'cookie') {\n      // Convert the cookie instance to an object, if possible\n      // This gets rid of the duplicate object under session.cookie.data property\n      // @ts-ignore FIXME:\n      obj.cookie = session.cookie.toJSON ?\n      // @ts-ignore FIXME:\n      session.cookie.toJSON() : session.cookie;\n    } else {\n      // @ts-ignore FIXME:\n      obj[prop] = session[prop];\n    }\n  }\n  return obj;\n}\nfunction computeTransformFunctions(options) {\n  if (options.serialize || options.unserialize) {\n    return {\n      serialize: options.serialize || defaultSerializeFunction,\n      unserialize: options.unserialize || unit\n    };\n  }\n  if (options.stringify === false) {\n    return {\n      serialize: defaultSerializeFunction,\n      unserialize: unit\n    };\n  }\n  // Default case\n  return {\n    serialize: JSON.stringify,\n    unserialize: JSON.parse\n  };\n}\nclass MongoStore extends session.Store {\n  constructor(_ref) {\n    let {\n      collectionName = 'sessions',\n      ttl = 1209600,\n      mongoOptions = {},\n      autoRemove = 'native',\n      autoRemoveInterval = 10,\n      touchAfter = 0,\n      stringify = true,\n      crypto,\n      ...required\n    } = _ref;\n    super();\n    this.crypto = null;\n    debug('create MongoStore instance');\n    const options = {\n      collectionName,\n      ttl,\n      mongoOptions,\n      autoRemove,\n      autoRemoveInterval,\n      touchAfter,\n      stringify,\n      crypto: {\n        ...{\n          secret: false,\n          algorithm: 'aes-256-gcm',\n          hashing: 'sha512',\n          encodeas: 'base64',\n          key_size: 32,\n          iv_size: 16,\n          at_size: 16\n        },\n        ...crypto\n      },\n      ...required\n    };\n    // Check params\n    (0, console_1.assert)(options.mongoUrl || options.clientPromise || options.client, 'You must provide either mongoUrl|clientPromise|client in options');\n    (0, console_1.assert)(options.createAutoRemoveIdx === null || options.createAutoRemoveIdx === undefined, 'options.createAutoRemoveIdx has been reverted to autoRemove and autoRemoveInterval');\n    (0, console_1.assert)(!options.autoRemoveInterval || options.autoRemoveInterval <= 71582, /* (Math.pow(2, 32) - 1) / (1000 * 60) */'autoRemoveInterval is too large. options.autoRemoveInterval is in minutes but not seconds nor mills');\n    this.transformFunctions = computeTransformFunctions(options);\n    let _clientP;\n    if (options.mongoUrl) {\n      _clientP = mongodb_1.MongoClient.connect(options.mongoUrl, options.mongoOptions);\n    } else if (options.clientPromise) {\n      _clientP = options.clientPromise;\n    } else if (options.client) {\n      _clientP = Promise.resolve(options.client);\n    } else {\n      throw new Error('Cannot init client. Please provide correct options');\n    }\n    (0, console_1.assert)(!!_clientP, 'Client is null|undefined');\n    this.clientP = _clientP;\n    this.options = options;\n    this.collectionP = _clientP.then(async con => {\n      const collection = con.db(options.dbName).collection(options.collectionName);\n      await this.setAutoRemove(collection);\n      return collection;\n    });\n    if (options.crypto.secret) {\n      this.crypto = require('kruptein')(options.crypto);\n    }\n  }\n  static create(options) {\n    return new MongoStore(options);\n  }\n  setAutoRemove(collection) {\n    const removeQuery = () => ({\n      expires: {\n        $lt: new Date()\n      }\n    });\n    switch (this.options.autoRemove) {\n      case 'native':\n        debug('Creating MongoDB TTL index');\n        return collection.createIndex({\n          expires: 1\n        }, {\n          background: true,\n          expireAfterSeconds: 0\n        });\n      case 'interval':\n        debug('create Timer to remove expired sessions');\n        this.timer = setInterval(() => collection.deleteMany(removeQuery(), {\n          writeConcern: {\n            w: 0,\n            j: false\n          }\n        }), this.options.autoRemoveInterval * 1000 * 60);\n        this.timer.unref();\n        return Promise.resolve();\n      case 'disabled':\n      default:\n        return Promise.resolve();\n    }\n  }\n  computeStorageId(sessionId) {\n    if (this.options.transformId && typeof this.options.transformId === 'function') {\n      return this.options.transformId(sessionId);\n    }\n    return sessionId;\n  }\n  /**\n   * promisify and bind the `this.crypto.get` function.\n   * Please check !!this.crypto === true before using this getter!\n   */\n  get cryptoGet() {\n    if (!this.crypto) {\n      throw new Error('Check this.crypto before calling this.cryptoGet!');\n    }\n    return util_1.default.promisify(this.crypto.get).bind(this.crypto);\n  }\n  /**\n   * Decrypt given session data\n   * @param session session data to be decrypt. Mutate the input session.\n   */\n  async decryptSession(session) {\n    if (this.crypto && session) {\n      const plaintext = await this.cryptoGet(this.options.crypto.secret, session.session).catch(err => {\n        throw new Error(err);\n      });\n      // @ts-ignore\n      session.session = JSON.parse(plaintext);\n    }\n  }\n  /**\n   * Get a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n  get(sid, callback) {\n    ;\n    (async () => {\n      try {\n        debug(\"MongoStore#get=\".concat(sid));\n        const collection = await this.collectionP;\n        const session = await collection.findOne({\n          _id: this.computeStorageId(sid),\n          $or: [{\n            expires: {\n              $exists: false\n            }\n          }, {\n            expires: {\n              $gt: new Date()\n            }\n          }]\n        });\n        if (this.crypto && session) {\n          await this.decryptSession(session).catch(err => callback(err));\n        }\n        const s = session && this.transformFunctions.unserialize(session.session);\n        if (this.options.touchAfter > 0 && (session === null || session === void 0 ? void 0 : session.lastModified)) {\n          s.lastModified = session.lastModified;\n        }\n        this.emit('get', sid);\n        callback(null, s === undefined ? null : s);\n      } catch (error) {\n        callback(error);\n      }\n    })();\n  }\n  /**\n   * Upsert a session into the store given a session ID (sid) and session (session) object.\n   * @param sid session ID\n   * @param session session object\n   */\n  set(sid, session) {\n    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n    ;\n    (async () => {\n      var _a;\n      try {\n        debug(\"MongoStore#set=\".concat(sid));\n        // Removing the lastModified prop from the session object before update\n        // @ts-ignore\n        if (this.options.touchAfter > 0 && (session === null || session === void 0 ? void 0 : session.lastModified)) {\n          // @ts-ignore\n          delete session.lastModified;\n        }\n        const s = {\n          _id: this.computeStorageId(sid),\n          session: this.transformFunctions.serialize(session)\n        };\n        // Expire handling\n        if ((_a = session === null || session === void 0 ? void 0 : session.cookie) === null || _a === void 0 ? void 0 : _a.expires) {\n          s.expires = new Date(session.cookie.expires);\n        } else {\n          // If there's no expiration date specified, it is\n          // browser-session cookie or there is no cookie at all,\n          // as per the connect docs.\n          //\n          // So we set the expiration to two-weeks from now\n          // - as is common practice in the industry (e.g Django) -\n          // or the default specified in the options.\n          s.expires = new Date(Date.now() + this.options.ttl * 1000);\n        }\n        // Last modify handling\n        if (this.options.touchAfter > 0) {\n          s.lastModified = new Date();\n        }\n        if (this.crypto) {\n          const cryptoSet = util_1.default.promisify(this.crypto.set).bind(this.crypto);\n          const data = await cryptoSet(this.options.crypto.secret, s.session).catch(err => {\n            throw new Error(err);\n          });\n          s.session = data;\n        }\n        const collection = await this.collectionP;\n        const rawResp = await collection.updateOne({\n          _id: s._id\n        }, {\n          $set: s\n        }, {\n          upsert: true,\n          writeConcern: this.options.writeOperationOptions\n        });\n        if (rawResp.upsertedCount > 0) {\n          this.emit('create', sid);\n        } else {\n          this.emit('update', sid);\n        }\n        this.emit('set', sid);\n      } catch (error) {\n        return callback(error);\n      }\n      return callback(null);\n    })();\n  }\n  touch(sid, session) {\n    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n    ;\n    (async () => {\n      var _a;\n      try {\n        debug(\"MongoStore#touch=\".concat(sid));\n        const updateFields = {};\n        const touchAfter = this.options.touchAfter * 1000;\n        const lastModified = session.lastModified ? session.lastModified.getTime() : 0;\n        const currentDate = new Date();\n        // If the given options has a touchAfter property, check if the\n        // current timestamp - lastModified timestamp is bigger than\n        // the specified, if it's not, don't touch the session\n        if (touchAfter > 0 && lastModified > 0) {\n          const timeElapsed = currentDate.getTime() - lastModified;\n          if (timeElapsed < touchAfter) {\n            debug(\"Skip touching session=\".concat(sid));\n            return callback(null);\n          }\n          updateFields.lastModified = currentDate;\n        }\n        if ((_a = session === null || session === void 0 ? void 0 : session.cookie) === null || _a === void 0 ? void 0 : _a.expires) {\n          updateFields.expires = new Date(session.cookie.expires);\n        } else {\n          updateFields.expires = new Date(Date.now() + this.options.ttl * 1000);\n        }\n        const collection = await this.collectionP;\n        const rawResp = await collection.updateOne({\n          _id: this.computeStorageId(sid)\n        }, {\n          $set: updateFields\n        }, {\n          writeConcern: this.options.writeOperationOptions\n        });\n        if (rawResp.matchedCount === 0) {\n          return callback(new Error('Unable to find the session to touch'));\n        } else {\n          this.emit('touch', sid, session);\n          return callback(null);\n        }\n      } catch (error) {\n        return callback(error);\n      }\n    })();\n  }\n  /**\n   * Get all sessions in the store as an array\n   */\n  all(callback) {\n    ;\n    (async () => {\n      try {\n        debug('MongoStore#all()');\n        const collection = await this.collectionP;\n        const sessions = collection.find({\n          $or: [{\n            expires: {\n              $exists: false\n            }\n          }, {\n            expires: {\n              $gt: new Date()\n            }\n          }]\n        });\n        const results = [];\n        for await (const session of sessions) {\n          if (this.crypto && session) {\n            await this.decryptSession(session);\n          }\n          results.push(this.transformFunctions.unserialize(session.session));\n        }\n        this.emit('all', results);\n        callback(null, results);\n      } catch (error) {\n        callback(error);\n      }\n    })();\n  }\n  /**\n   * Destroy/delete a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n  destroy(sid) {\n    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n    debug(\"MongoStore#destroy=\".concat(sid));\n    this.collectionP.then(colleciton => colleciton.deleteOne({\n      _id: this.computeStorageId(sid)\n    }, {\n      writeConcern: this.options.writeOperationOptions\n    })).then(() => {\n      this.emit('destroy', sid);\n      callback(null);\n    }).catch(err => callback(err));\n  }\n  /**\n   * Get the count of all sessions in the store\n   */\n  length(callback) {\n    debug('MongoStore#length()');\n    this.collectionP.then(collection => collection.countDocuments()).then(c => callback(null, c))\n    // @ts-ignore\n    .catch(err => callback(err));\n  }\n  /**\n   * Delete all sessions from the store.\n   */\n  clear() {\n    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;\n    debug('MongoStore#clear()');\n    this.collectionP.then(collection => collection.drop()).then(() => callback(null)).catch(err => callback(err));\n  }\n  /**\n   * Close database connection\n   */\n  close() {\n    debug('MongoStore#close()');\n    return this.clientP.then(c => c.close());\n  }\n}\nexports.default = MongoStore;","map":{"version":3,"names":["console_1","require","util_1","__importDefault","session","__importStar","mongodb_1","debug_1","debug","default","noop","unit","a","defaultSerializeFunction","obj","prop","cookie","toJSON","computeTransformFunctions","options","serialize","unserialize","stringify","JSON","parse","MongoStore","Store","constructor","_ref","collectionName","ttl","mongoOptions","autoRemove","autoRemoveInterval","touchAfter","crypto","required","secret","algorithm","hashing","encodeas","key_size","iv_size","at_size","assert","mongoUrl","clientPromise","client","createAutoRemoveIdx","undefined","transformFunctions","_clientP","MongoClient","connect","Promise","resolve","Error","clientP","collectionP","then","con","collection","db","dbName","setAutoRemove","create","removeQuery","expires","$lt","Date","createIndex","background","expireAfterSeconds","timer","setInterval","deleteMany","writeConcern","w","j","unref","computeStorageId","sessionId","transformId","cryptoGet","promisify","get","bind","decryptSession","plaintext","catch","err","sid","callback","concat","findOne","_id","$or","$exists","$gt","s","lastModified","emit","error","set","arguments","length","_a","now","cryptoSet","data","rawResp","updateOne","$set","upsert","writeOperationOptions","upsertedCount","touch","updateFields","getTime","currentDate","timeElapsed","matchedCount","all","sessions","find","results","push","destroy","colleciton","deleteOne","countDocuments","c","clear","drop","close","exports"],"sources":["/Users/akamurasaki/hackathonfinal-1/hackathon-front-main/node_modules/connect-mongo/src/lib/MongoStore.ts"],"sourcesContent":["import { assert } from 'console'\nimport util from 'util'\nimport * as session from 'express-session'\nimport {\n  Collection,\n  MongoClient,\n  MongoClientOptions,\n  WriteConcernSettings,\n} from 'mongodb'\nimport Debug from 'debug'\nimport Kruptein from 'kruptein'\n\nconst debug = Debug('connect-mongo')\n\nexport type CryptoOptions = {\n  secret: false | string\n  algorithm?: string\n  hashing?: string\n  encodeas?: string\n  key_size?: number\n  iv_size?: number\n  at_size?: number\n}\n\nexport type ConnectMongoOptions = {\n  mongoUrl?: string\n  clientPromise?: Promise<MongoClient>\n  client?: MongoClient\n  collectionName?: string\n  mongoOptions?: MongoClientOptions\n  dbName?: string\n  ttl?: number\n  touchAfter?: number\n  stringify?: boolean\n  createAutoRemoveIdx?: boolean\n  autoRemove?: 'native' | 'interval' | 'disabled'\n  autoRemoveInterval?: number\n  // FIXME: remove those any\n  serialize?: (a: any) => any\n  unserialize?: (a: any) => any\n  writeOperationOptions?: WriteConcernSettings\n  transformId?: (a: any) => any\n  crypto?: CryptoOptions\n}\n\ntype ConcretCryptoOptions = Required<CryptoOptions>\n\ntype ConcretConnectMongoOptions = {\n  mongoUrl?: string\n  clientPromise?: Promise<MongoClient>\n  client?: MongoClient\n  collectionName: string\n  mongoOptions: MongoClientOptions\n  dbName?: string\n  ttl: number\n  createAutoRemoveIdx?: boolean\n  autoRemove: 'native' | 'interval' | 'disabled'\n  autoRemoveInterval: number\n  touchAfter: number\n  stringify: boolean\n  // FIXME: remove those any\n  serialize?: (a: any) => any\n  unserialize?: (a: any) => any\n  writeOperationOptions?: WriteConcernSettings\n  transformId?: (a: any) => any\n  // FIXME: remove above any\n  crypto: ConcretCryptoOptions\n}\n\ntype InternalSessionType = {\n  _id: string\n  session: any\n  expires?: Date\n  lastModified?: Date\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {}\nconst unit: <T>(a: T) => T = (a) => a\n\nfunction defaultSerializeFunction(\n  session: session.SessionData\n): session.SessionData {\n  // Copy each property of the session to a new object\n  const obj = {}\n  let prop\n  for (prop in session) {\n    if (prop === 'cookie') {\n      // Convert the cookie instance to an object, if possible\n      // This gets rid of the duplicate object under session.cookie.data property\n      // @ts-ignore FIXME:\n      obj.cookie = session.cookie.toJSON\n        ? // @ts-ignore FIXME:\n          session.cookie.toJSON()\n        : session.cookie\n    } else {\n      // @ts-ignore FIXME:\n      obj[prop] = session[prop]\n    }\n  }\n\n  return obj as session.SessionData\n}\n\nfunction computeTransformFunctions(options: ConcretConnectMongoOptions) {\n  if (options.serialize || options.unserialize) {\n    return {\n      serialize: options.serialize || defaultSerializeFunction,\n      unserialize: options.unserialize || unit,\n    }\n  }\n\n  if (options.stringify === false) {\n    return {\n      serialize: defaultSerializeFunction,\n      unserialize: unit,\n    }\n  }\n  // Default case\n  return {\n    serialize: JSON.stringify,\n    unserialize: JSON.parse,\n  }\n}\n\nexport default class MongoStore extends session.Store {\n  private clientP: Promise<MongoClient>\n  private crypto: Kruptein | null = null\n  private timer?: NodeJS.Timeout\n  collectionP: Promise<Collection<InternalSessionType>>\n  private options: ConcretConnectMongoOptions\n  // FIXME: remvoe any\n  private transformFunctions: {\n    serialize: (a: any) => any\n    unserialize: (a: any) => any\n  }\n\n  constructor({\n    collectionName = 'sessions',\n    ttl = 1209600,\n    mongoOptions = {},\n    autoRemove = 'native',\n    autoRemoveInterval = 10,\n    touchAfter = 0,\n    stringify = true,\n    crypto,\n    ...required\n  }: ConnectMongoOptions) {\n    super()\n    debug('create MongoStore instance')\n    const options: ConcretConnectMongoOptions = {\n      collectionName,\n      ttl,\n      mongoOptions,\n      autoRemove,\n      autoRemoveInterval,\n      touchAfter,\n      stringify,\n      crypto: {\n        ...{\n          secret: false,\n          algorithm: 'aes-256-gcm',\n          hashing: 'sha512',\n          encodeas: 'base64',\n          key_size: 32,\n          iv_size: 16,\n          at_size: 16,\n        },\n        ...crypto,\n      },\n      ...required,\n    }\n    // Check params\n    assert(\n      options.mongoUrl || options.clientPromise || options.client,\n      'You must provide either mongoUrl|clientPromise|client in options'\n    )\n    assert(\n      options.createAutoRemoveIdx === null ||\n        options.createAutoRemoveIdx === undefined,\n      'options.createAutoRemoveIdx has been reverted to autoRemove and autoRemoveInterval'\n    )\n    assert(\n      !options.autoRemoveInterval || options.autoRemoveInterval <= 71582,\n      /* (Math.pow(2, 32) - 1) / (1000 * 60) */ 'autoRemoveInterval is too large. options.autoRemoveInterval is in minutes but not seconds nor mills'\n    )\n    this.transformFunctions = computeTransformFunctions(options)\n    let _clientP: Promise<MongoClient>\n    if (options.mongoUrl) {\n      _clientP = MongoClient.connect(options.mongoUrl, options.mongoOptions)\n    } else if (options.clientPromise) {\n      _clientP = options.clientPromise\n    } else if (options.client) {\n      _clientP = Promise.resolve(options.client)\n    } else {\n      throw new Error('Cannot init client. Please provide correct options')\n    }\n    assert(!!_clientP, 'Client is null|undefined')\n    this.clientP = _clientP\n    this.options = options\n    this.collectionP = _clientP.then(async (con) => {\n      const collection = con\n        .db(options.dbName)\n        .collection<InternalSessionType>(options.collectionName)\n      await this.setAutoRemove(collection)\n      return collection\n    })\n    if (options.crypto.secret) {\n      this.crypto = require('kruptein')(options.crypto)\n    }\n  }\n\n  static create(options: ConnectMongoOptions): MongoStore {\n    return new MongoStore(options)\n  }\n\n  private setAutoRemove(\n    collection: Collection<InternalSessionType>\n  ): Promise<unknown> {\n    const removeQuery = () => ({\n      expires: {\n        $lt: new Date(),\n      },\n    })\n    switch (this.options.autoRemove) {\n      case 'native':\n        debug('Creating MongoDB TTL index')\n        return collection.createIndex(\n          { expires: 1 },\n          {\n            background: true,\n            expireAfterSeconds: 0,\n          }\n        )\n      case 'interval':\n        debug('create Timer to remove expired sessions')\n        this.timer = setInterval(\n          () =>\n            collection.deleteMany(removeQuery(), {\n              writeConcern: {\n                w: 0,\n                j: false,\n              },\n            }),\n          this.options.autoRemoveInterval * 1000 * 60\n        )\n        this.timer.unref()\n        return Promise.resolve()\n      case 'disabled':\n      default:\n        return Promise.resolve()\n    }\n  }\n\n  private computeStorageId(sessionId: string) {\n    if (\n      this.options.transformId &&\n      typeof this.options.transformId === 'function'\n    ) {\n      return this.options.transformId(sessionId)\n    }\n    return sessionId\n  }\n\n  /**\n   * promisify and bind the `this.crypto.get` function.\n   * Please check !!this.crypto === true before using this getter!\n   */\n  private get cryptoGet() {\n    if (!this.crypto) {\n      throw new Error('Check this.crypto before calling this.cryptoGet!')\n    }\n    return util.promisify(this.crypto.get).bind(this.crypto)\n  }\n\n  /**\n   * Decrypt given session data\n   * @param session session data to be decrypt. Mutate the input session.\n   */\n  private async decryptSession(\n    session: session.SessionData | undefined | null\n  ) {\n    if (this.crypto && session) {\n      const plaintext = await this.cryptoGet(\n        this.options.crypto.secret as string,\n        session.session\n      ).catch((err) => {\n        throw new Error(err)\n      })\n      // @ts-ignore\n      session.session = JSON.parse(plaintext)\n    }\n  }\n\n  /**\n   * Get a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n  get(\n    sid: string,\n    callback: (err: any, session?: session.SessionData | null) => void\n  ): void {\n    ;(async () => {\n      try {\n        debug(`MongoStore#get=${sid}`)\n        const collection = await this.collectionP\n        const session = await collection.findOne({\n          _id: this.computeStorageId(sid),\n          $or: [\n            { expires: { $exists: false } },\n            { expires: { $gt: new Date() } },\n          ],\n        })\n        if (this.crypto && session) {\n          await this.decryptSession(\n            session as unknown as session.SessionData\n          ).catch((err) => callback(err))\n        }\n        const s =\n          session && this.transformFunctions.unserialize(session.session)\n        if (this.options.touchAfter > 0 && session?.lastModified) {\n          s.lastModified = session.lastModified\n        }\n        this.emit('get', sid)\n        callback(null, s === undefined ? null : s)\n      } catch (error) {\n        callback(error)\n      }\n    })()\n  }\n\n  /**\n   * Upsert a session into the store given a session ID (sid) and session (session) object.\n   * @param sid session ID\n   * @param session session object\n   */\n  set(\n    sid: string,\n    session: session.SessionData,\n    callback: (err: any) => void = noop\n  ): void {\n    ;(async () => {\n      try {\n        debug(`MongoStore#set=${sid}`)\n        // Removing the lastModified prop from the session object before update\n        // @ts-ignore\n        if (this.options.touchAfter > 0 && session?.lastModified) {\n          // @ts-ignore\n          delete session.lastModified\n        }\n        const s: InternalSessionType = {\n          _id: this.computeStorageId(sid),\n          session: this.transformFunctions.serialize(session),\n        }\n        // Expire handling\n        if (session?.cookie?.expires) {\n          s.expires = new Date(session.cookie.expires)\n        } else {\n          // If there's no expiration date specified, it is\n          // browser-session cookie or there is no cookie at all,\n          // as per the connect docs.\n          //\n          // So we set the expiration to two-weeks from now\n          // - as is common practice in the industry (e.g Django) -\n          // or the default specified in the options.\n          s.expires = new Date(Date.now() + this.options.ttl * 1000)\n        }\n        // Last modify handling\n        if (this.options.touchAfter > 0) {\n          s.lastModified = new Date()\n        }\n        if (this.crypto) {\n          const cryptoSet = util.promisify(this.crypto.set).bind(this.crypto)\n          const data = await cryptoSet(\n            this.options.crypto.secret as string,\n            s.session\n          ).catch((err) => {\n            throw new Error(err)\n          })\n          s.session = data as unknown as session.SessionData\n        }\n        const collection = await this.collectionP\n        const rawResp = await collection.updateOne(\n          { _id: s._id },\n          { $set: s },\n          {\n            upsert: true,\n            writeConcern: this.options.writeOperationOptions,\n          }\n        )\n        if (rawResp.upsertedCount > 0) {\n          this.emit('create', sid)\n        } else {\n          this.emit('update', sid)\n        }\n        this.emit('set', sid)\n      } catch (error) {\n        return callback(error)\n      }\n      return callback(null)\n    })()\n  }\n\n  touch(\n    sid: string,\n    session: session.SessionData & { lastModified?: Date },\n    callback: (err: any) => void = noop\n  ): void {\n    ;(async () => {\n      try {\n        debug(`MongoStore#touch=${sid}`)\n        const updateFields: {\n          lastModified?: Date\n          expires?: Date\n          session?: session.SessionData\n        } = {}\n        const touchAfter = this.options.touchAfter * 1000\n        const lastModified = session.lastModified\n          ? session.lastModified.getTime()\n          : 0\n        const currentDate = new Date()\n\n        // If the given options has a touchAfter property, check if the\n        // current timestamp - lastModified timestamp is bigger than\n        // the specified, if it's not, don't touch the session\n        if (touchAfter > 0 && lastModified > 0) {\n          const timeElapsed = currentDate.getTime() - lastModified\n          if (timeElapsed < touchAfter) {\n            debug(`Skip touching session=${sid}`)\n            return callback(null)\n          }\n          updateFields.lastModified = currentDate\n        }\n\n        if (session?.cookie?.expires) {\n          updateFields.expires = new Date(session.cookie.expires)\n        } else {\n          updateFields.expires = new Date(Date.now() + this.options.ttl * 1000)\n        }\n        const collection = await this.collectionP\n        const rawResp = await collection.updateOne(\n          { _id: this.computeStorageId(sid) },\n          { $set: updateFields },\n          { writeConcern: this.options.writeOperationOptions }\n        )\n        if (rawResp.matchedCount === 0) {\n          return callback(new Error('Unable to find the session to touch'))\n        } else {\n          this.emit('touch', sid, session)\n          return callback(null)\n        }\n      } catch (error) {\n        return callback(error)\n      }\n    })()\n  }\n\n  /**\n   * Get all sessions in the store as an array\n   */\n  all(\n    callback: (\n      err: any,\n      obj?:\n        | session.SessionData[]\n        | { [sid: string]: session.SessionData }\n        | null\n    ) => void\n  ): void {\n    ;(async () => {\n      try {\n        debug('MongoStore#all()')\n        const collection = await this.collectionP\n        const sessions = collection.find({\n          $or: [\n            { expires: { $exists: false } },\n            { expires: { $gt: new Date() } },\n          ],\n        })\n        const results: session.SessionData[] = []\n        for await (const session of sessions) {\n          if (this.crypto && session) {\n            await this.decryptSession(session as unknown as session.SessionData)\n          }\n          results.push(this.transformFunctions.unserialize(session.session))\n        }\n        this.emit('all', results)\n        callback(null, results)\n      } catch (error) {\n        callback(error)\n      }\n    })()\n  }\n\n  /**\n   * Destroy/delete a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n  destroy(sid: string, callback: (err: any) => void = noop): void {\n    debug(`MongoStore#destroy=${sid}`)\n    this.collectionP\n      .then((colleciton) =>\n        colleciton.deleteOne(\n          { _id: this.computeStorageId(sid) },\n          { writeConcern: this.options.writeOperationOptions }\n        )\n      )\n      .then(() => {\n        this.emit('destroy', sid)\n        callback(null)\n      })\n      .catch((err) => callback(err))\n  }\n\n  /**\n   * Get the count of all sessions in the store\n   */\n  length(callback: (err: any, length: number) => void): void {\n    debug('MongoStore#length()')\n    this.collectionP\n      .then((collection) => collection.countDocuments())\n      .then((c) => callback(null, c))\n      // @ts-ignore\n      .catch((err) => callback(err))\n  }\n\n  /**\n   * Delete all sessions from the store.\n   */\n  clear(callback: (err: any) => void = noop): void {\n    debug('MongoStore#clear()')\n    this.collectionP\n      .then((collection) => collection.drop())\n      .then(() => callback(null))\n      .catch((err) => callback(err))\n  }\n\n  /**\n   * Close database connection\n   */\n  close(): Promise<void> {\n    debug('MongoStore#close()')\n    return this.clientP.then((c) => c.close())\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}