{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst console_1 = require(\"console\");\nconst util_1 = __importDefault(require(\"util\"));\nconst session = __importStar(require(\"express-session\"));\nconst mongodb_1 = require(\"mongodb\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)('connect-mongo');\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\nconst unit = a => a;\nfunction defaultSerializeFunction(session) {\n  // Copy each property of the session to a new object\n  const obj = {};\n  let prop;\n  for (prop in session) {\n    if (prop === 'cookie') {\n      // Convert the cookie instance to an object, if possible\n      // This gets rid of the duplicate object under session.cookie.data property\n      // @ts-ignore FIXME:\n      obj.cookie = session.cookie.toJSON ?\n      // @ts-ignore FIXME:\n      session.cookie.toJSON() : session.cookie;\n    } else {\n      // @ts-ignore FIXME:\n      obj[prop] = session[prop];\n    }\n  }\n  return obj;\n}\nfunction computeTransformFunctions(options) {\n  if (options.serialize || options.unserialize) {\n    return {\n      serialize: options.serialize || defaultSerializeFunction,\n      unserialize: options.unserialize || unit\n    };\n  }\n  if (options.stringify === false) {\n    return {\n      serialize: defaultSerializeFunction,\n      unserialize: unit\n    };\n  }\n  // Default case\n  return {\n    serialize: JSON.stringify,\n    unserialize: JSON.parse\n  };\n}\nclass MongoStore extends session.Store {\n  constructor({\n    collectionName = 'sessions',\n    ttl = 1209600,\n    mongoOptions = {},\n    autoRemove = 'native',\n    autoRemoveInterval = 10,\n    touchAfter = 0,\n    stringify = true,\n    crypto,\n    ...required\n  }) {\n    super();\n    this.crypto = null;\n    debug('create MongoStore instance');\n    const options = {\n      collectionName,\n      ttl,\n      mongoOptions,\n      autoRemove,\n      autoRemoveInterval,\n      touchAfter,\n      stringify,\n      crypto: {\n        ...{\n          secret: false,\n          algorithm: 'aes-256-gcm',\n          hashing: 'sha512',\n          encodeas: 'base64',\n          key_size: 32,\n          iv_size: 16,\n          at_size: 16\n        },\n        ...crypto\n      },\n      ...required\n    };\n    // Check params\n    (0, console_1.assert)(options.mongoUrl || options.clientPromise || options.client, 'You must provide either mongoUrl|clientPromise|client in options');\n    (0, console_1.assert)(options.createAutoRemoveIdx === null || options.createAutoRemoveIdx === undefined, 'options.createAutoRemoveIdx has been reverted to autoRemove and autoRemoveInterval');\n    (0, console_1.assert)(!options.autoRemoveInterval || options.autoRemoveInterval <= 71582, /* (Math.pow(2, 32) - 1) / (1000 * 60) */'autoRemoveInterval is too large. options.autoRemoveInterval is in minutes but not seconds nor mills');\n    this.transformFunctions = computeTransformFunctions(options);\n    let _clientP;\n    if (options.mongoUrl) {\n      _clientP = mongodb_1.MongoClient.connect(options.mongoUrl, options.mongoOptions);\n    } else if (options.clientPromise) {\n      _clientP = options.clientPromise;\n    } else if (options.client) {\n      _clientP = Promise.resolve(options.client);\n    } else {\n      throw new Error('Cannot init client. Please provide correct options');\n    }\n    (0, console_1.assert)(!!_clientP, 'Client is null|undefined');\n    this.clientP = _clientP;\n    this.options = options;\n    this.collectionP = _clientP.then(async con => {\n      const collection = con.db(options.dbName).collection(options.collectionName);\n      await this.setAutoRemove(collection);\n      return collection;\n    });\n    if (options.crypto.secret) {\n      this.crypto = require('kruptein')(options.crypto);\n    }\n  }\n  static create(options) {\n    return new MongoStore(options);\n  }\n  setAutoRemove(collection) {\n    const removeQuery = () => ({\n      expires: {\n        $lt: new Date()\n      }\n    });\n    switch (this.options.autoRemove) {\n      case 'native':\n        debug('Creating MongoDB TTL index');\n        return collection.createIndex({\n          expires: 1\n        }, {\n          background: true,\n          expireAfterSeconds: 0\n        });\n      case 'interval':\n        debug('create Timer to remove expired sessions');\n        this.timer = setInterval(() => collection.deleteMany(removeQuery(), {\n          writeConcern: {\n            w: 0,\n            j: false\n          }\n        }), this.options.autoRemoveInterval * 1000 * 60);\n        this.timer.unref();\n        return Promise.resolve();\n      case 'disabled':\n      default:\n        return Promise.resolve();\n    }\n  }\n  computeStorageId(sessionId) {\n    if (this.options.transformId && typeof this.options.transformId === 'function') {\n      return this.options.transformId(sessionId);\n    }\n    return sessionId;\n  }\n  /**\n   * promisify and bind the `this.crypto.get` function.\n   * Please check !!this.crypto === true before using this getter!\n   */\n  get cryptoGet() {\n    if (!this.crypto) {\n      throw new Error('Check this.crypto before calling this.cryptoGet!');\n    }\n    return util_1.default.promisify(this.crypto.get).bind(this.crypto);\n  }\n  /**\n   * Decrypt given session data\n   * @param session session data to be decrypt. Mutate the input session.\n   */\n  async decryptSession(session) {\n    if (this.crypto && session) {\n      const plaintext = await this.cryptoGet(this.options.crypto.secret, session.session).catch(err => {\n        throw new Error(err);\n      });\n      // @ts-ignore\n      session.session = JSON.parse(plaintext);\n    }\n  }\n  /**\n   * Get a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n  get(sid, callback) {\n    ;\n    (async () => {\n      try {\n        debug(`MongoStore#get=${sid}`);\n        const collection = await this.collectionP;\n        const session = await collection.findOne({\n          _id: this.computeStorageId(sid),\n          $or: [{\n            expires: {\n              $exists: false\n            }\n          }, {\n            expires: {\n              $gt: new Date()\n            }\n          }]\n        });\n        if (this.crypto && session) {\n          await this.decryptSession(session).catch(err => callback(err));\n        }\n        const s = session && this.transformFunctions.unserialize(session.session);\n        if (this.options.touchAfter > 0 && (session === null || session === void 0 ? void 0 : session.lastModified)) {\n          s.lastModified = session.lastModified;\n        }\n        this.emit('get', sid);\n        callback(null, s === undefined ? null : s);\n      } catch (error) {\n        callback(error);\n      }\n    })();\n  }\n  /**\n   * Upsert a session into the store given a session ID (sid) and session (session) object.\n   * @param sid session ID\n   * @param session session object\n   */\n  set(sid, session, callback = noop) {\n    ;\n    (async () => {\n      var _a;\n      try {\n        debug(`MongoStore#set=${sid}`);\n        // Removing the lastModified prop from the session object before update\n        // @ts-ignore\n        if (this.options.touchAfter > 0 && (session === null || session === void 0 ? void 0 : session.lastModified)) {\n          // @ts-ignore\n          delete session.lastModified;\n        }\n        const s = {\n          _id: this.computeStorageId(sid),\n          session: this.transformFunctions.serialize(session)\n        };\n        // Expire handling\n        if ((_a = session === null || session === void 0 ? void 0 : session.cookie) === null || _a === void 0 ? void 0 : _a.expires) {\n          s.expires = new Date(session.cookie.expires);\n        } else {\n          // If there's no expiration date specified, it is\n          // browser-session cookie or there is no cookie at all,\n          // as per the connect docs.\n          //\n          // So we set the expiration to two-weeks from now\n          // - as is common practice in the industry (e.g Django) -\n          // or the default specified in the options.\n          s.expires = new Date(Date.now() + this.options.ttl * 1000);\n        }\n        // Last modify handling\n        if (this.options.touchAfter > 0) {\n          s.lastModified = new Date();\n        }\n        if (this.crypto) {\n          const cryptoSet = util_1.default.promisify(this.crypto.set).bind(this.crypto);\n          const data = await cryptoSet(this.options.crypto.secret, s.session).catch(err => {\n            throw new Error(err);\n          });\n          s.session = data;\n        }\n        const collection = await this.collectionP;\n        const rawResp = await collection.updateOne({\n          _id: s._id\n        }, {\n          $set: s\n        }, {\n          upsert: true,\n          writeConcern: this.options.writeOperationOptions\n        });\n        if (rawResp.upsertedCount > 0) {\n          this.emit('create', sid);\n        } else {\n          this.emit('update', sid);\n        }\n        this.emit('set', sid);\n      } catch (error) {\n        return callback(error);\n      }\n      return callback(null);\n    })();\n  }\n  touch(sid, session, callback = noop) {\n    ;\n    (async () => {\n      var _a;\n      try {\n        debug(`MongoStore#touch=${sid}`);\n        const updateFields = {};\n        const touchAfter = this.options.touchAfter * 1000;\n        const lastModified = session.lastModified ? session.lastModified.getTime() : 0;\n        const currentDate = new Date();\n        // If the given options has a touchAfter property, check if the\n        // current timestamp - lastModified timestamp is bigger than\n        // the specified, if it's not, don't touch the session\n        if (touchAfter > 0 && lastModified > 0) {\n          const timeElapsed = currentDate.getTime() - lastModified;\n          if (timeElapsed < touchAfter) {\n            debug(`Skip touching session=${sid}`);\n            return callback(null);\n          }\n          updateFields.lastModified = currentDate;\n        }\n        if ((_a = session === null || session === void 0 ? void 0 : session.cookie) === null || _a === void 0 ? void 0 : _a.expires) {\n          updateFields.expires = new Date(session.cookie.expires);\n        } else {\n          updateFields.expires = new Date(Date.now() + this.options.ttl * 1000);\n        }\n        const collection = await this.collectionP;\n        const rawResp = await collection.updateOne({\n          _id: this.computeStorageId(sid)\n        }, {\n          $set: updateFields\n        }, {\n          writeConcern: this.options.writeOperationOptions\n        });\n        if (rawResp.matchedCount === 0) {\n          return callback(new Error('Unable to find the session to touch'));\n        } else {\n          this.emit('touch', sid, session);\n          return callback(null);\n        }\n      } catch (error) {\n        return callback(error);\n      }\n    })();\n  }\n  /**\n   * Get all sessions in the store as an array\n   */\n  all(callback) {\n    ;\n    (async () => {\n      try {\n        debug('MongoStore#all()');\n        const collection = await this.collectionP;\n        const sessions = collection.find({\n          $or: [{\n            expires: {\n              $exists: false\n            }\n          }, {\n            expires: {\n              $gt: new Date()\n            }\n          }]\n        });\n        const results = [];\n        for await (const session of sessions) {\n          if (this.crypto && session) {\n            await this.decryptSession(session);\n          }\n          results.push(this.transformFunctions.unserialize(session.session));\n        }\n        this.emit('all', results);\n        callback(null, results);\n      } catch (error) {\n        callback(error);\n      }\n    })();\n  }\n  /**\n   * Destroy/delete a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n  destroy(sid, callback = noop) {\n    debug(`MongoStore#destroy=${sid}`);\n    this.collectionP.then(colleciton => colleciton.deleteOne({\n      _id: this.computeStorageId(sid)\n    }, {\n      writeConcern: this.options.writeOperationOptions\n    })).then(() => {\n      this.emit('destroy', sid);\n      callback(null);\n    }).catch(err => callback(err));\n  }\n  /**\n   * Get the count of all sessions in the store\n   */\n  length(callback) {\n    debug('MongoStore#length()');\n    this.collectionP.then(collection => collection.countDocuments()).then(c => callback(null, c))\n    // @ts-ignore\n    .catch(err => callback(err));\n  }\n  /**\n   * Delete all sessions from the store.\n   */\n  clear(callback = noop) {\n    debug('MongoStore#clear()');\n    this.collectionP.then(collection => collection.drop()).then(() => callback(null)).catch(err => callback(err));\n  }\n  /**\n   * Close database connection\n   */\n  close() {\n    debug('MongoStore#close()');\n    return this.clientP.then(c => c.close());\n  }\n}\nexports.default = MongoStore;","map":{"version":3,"names":["console_1","require","util_1","__importDefault","session","__importStar","mongodb_1","debug_1","debug","default","noop","unit","a","defaultSerializeFunction","obj","prop","cookie","toJSON","computeTransformFunctions","options","serialize","unserialize","stringify","JSON","parse","MongoStore","Store","constructor","collectionName","ttl","mongoOptions","autoRemove","autoRemoveInterval","touchAfter","crypto","required","secret","algorithm","hashing","encodeas","key_size","iv_size","at_size","assert","mongoUrl","clientPromise","client","createAutoRemoveIdx","undefined","transformFunctions","_clientP","MongoClient","connect","Promise","resolve","Error","clientP","collectionP","then","con","collection","db","dbName","setAutoRemove","create","removeQuery","expires","$lt","Date","createIndex","background","expireAfterSeconds","timer","setInterval","deleteMany","writeConcern","w","j","unref","computeStorageId","sessionId","transformId","cryptoGet","promisify","get","bind","decryptSession","plaintext","catch","err","sid","callback","findOne","_id","$or","$exists","$gt","s","lastModified","emit","error","set","_a","now","cryptoSet","data","rawResp","updateOne","$set","upsert","writeOperationOptions","upsertedCount","touch","updateFields","getTime","currentDate","timeElapsed","matchedCount","all","sessions","find","results","push","destroy","colleciton","deleteOne","length","countDocuments","c","clear","drop","close","exports"],"sources":["/Users/akamurasaki/hackathonfinal-1/hackathon-front-main/node_modules/connect-mongo/src/lib/MongoStore.ts"],"sourcesContent":["import { assert } from 'console'\nimport util from 'util'\nimport * as session from 'express-session'\nimport {\n  Collection,\n  MongoClient,\n  MongoClientOptions,\n  WriteConcernSettings,\n} from 'mongodb'\nimport Debug from 'debug'\nimport Kruptein from 'kruptein'\n\nconst debug = Debug('connect-mongo')\n\nexport type CryptoOptions = {\n  secret: false | string\n  algorithm?: string\n  hashing?: string\n  encodeas?: string\n  key_size?: number\n  iv_size?: number\n  at_size?: number\n}\n\nexport type ConnectMongoOptions = {\n  mongoUrl?: string\n  clientPromise?: Promise<MongoClient>\n  client?: MongoClient\n  collectionName?: string\n  mongoOptions?: MongoClientOptions\n  dbName?: string\n  ttl?: number\n  touchAfter?: number\n  stringify?: boolean\n  createAutoRemoveIdx?: boolean\n  autoRemove?: 'native' | 'interval' | 'disabled'\n  autoRemoveInterval?: number\n  // FIXME: remove those any\n  serialize?: (a: any) => any\n  unserialize?: (a: any) => any\n  writeOperationOptions?: WriteConcernSettings\n  transformId?: (a: any) => any\n  crypto?: CryptoOptions\n}\n\ntype ConcretCryptoOptions = Required<CryptoOptions>\n\ntype ConcretConnectMongoOptions = {\n  mongoUrl?: string\n  clientPromise?: Promise<MongoClient>\n  client?: MongoClient\n  collectionName: string\n  mongoOptions: MongoClientOptions\n  dbName?: string\n  ttl: number\n  createAutoRemoveIdx?: boolean\n  autoRemove: 'native' | 'interval' | 'disabled'\n  autoRemoveInterval: number\n  touchAfter: number\n  stringify: boolean\n  // FIXME: remove those any\n  serialize?: (a: any) => any\n  unserialize?: (a: any) => any\n  writeOperationOptions?: WriteConcernSettings\n  transformId?: (a: any) => any\n  // FIXME: remove above any\n  crypto: ConcretCryptoOptions\n}\n\ntype InternalSessionType = {\n  _id: string\n  session: any\n  expires?: Date\n  lastModified?: Date\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {}\nconst unit: <T>(a: T) => T = (a) => a\n\nfunction defaultSerializeFunction(\n  session: session.SessionData\n): session.SessionData {\n  // Copy each property of the session to a new object\n  const obj = {}\n  let prop\n  for (prop in session) {\n    if (prop === 'cookie') {\n      // Convert the cookie instance to an object, if possible\n      // This gets rid of the duplicate object under session.cookie.data property\n      // @ts-ignore FIXME:\n      obj.cookie = session.cookie.toJSON\n        ? // @ts-ignore FIXME:\n          session.cookie.toJSON()\n        : session.cookie\n    } else {\n      // @ts-ignore FIXME:\n      obj[prop] = session[prop]\n    }\n  }\n\n  return obj as session.SessionData\n}\n\nfunction computeTransformFunctions(options: ConcretConnectMongoOptions) {\n  if (options.serialize || options.unserialize) {\n    return {\n      serialize: options.serialize || defaultSerializeFunction,\n      unserialize: options.unserialize || unit,\n    }\n  }\n\n  if (options.stringify === false) {\n    return {\n      serialize: defaultSerializeFunction,\n      unserialize: unit,\n    }\n  }\n  // Default case\n  return {\n    serialize: JSON.stringify,\n    unserialize: JSON.parse,\n  }\n}\n\nexport default class MongoStore extends session.Store {\n  private clientP: Promise<MongoClient>\n  private crypto: Kruptein | null = null\n  private timer?: NodeJS.Timeout\n  collectionP: Promise<Collection<InternalSessionType>>\n  private options: ConcretConnectMongoOptions\n  // FIXME: remvoe any\n  private transformFunctions: {\n    serialize: (a: any) => any\n    unserialize: (a: any) => any\n  }\n\n  constructor({\n    collectionName = 'sessions',\n    ttl = 1209600,\n    mongoOptions = {},\n    autoRemove = 'native',\n    autoRemoveInterval = 10,\n    touchAfter = 0,\n    stringify = true,\n    crypto,\n    ...required\n  }: ConnectMongoOptions) {\n    super()\n    debug('create MongoStore instance')\n    const options: ConcretConnectMongoOptions = {\n      collectionName,\n      ttl,\n      mongoOptions,\n      autoRemove,\n      autoRemoveInterval,\n      touchAfter,\n      stringify,\n      crypto: {\n        ...{\n          secret: false,\n          algorithm: 'aes-256-gcm',\n          hashing: 'sha512',\n          encodeas: 'base64',\n          key_size: 32,\n          iv_size: 16,\n          at_size: 16,\n        },\n        ...crypto,\n      },\n      ...required,\n    }\n    // Check params\n    assert(\n      options.mongoUrl || options.clientPromise || options.client,\n      'You must provide either mongoUrl|clientPromise|client in options'\n    )\n    assert(\n      options.createAutoRemoveIdx === null ||\n        options.createAutoRemoveIdx === undefined,\n      'options.createAutoRemoveIdx has been reverted to autoRemove and autoRemoveInterval'\n    )\n    assert(\n      !options.autoRemoveInterval || options.autoRemoveInterval <= 71582,\n      /* (Math.pow(2, 32) - 1) / (1000 * 60) */ 'autoRemoveInterval is too large. options.autoRemoveInterval is in minutes but not seconds nor mills'\n    )\n    this.transformFunctions = computeTransformFunctions(options)\n    let _clientP: Promise<MongoClient>\n    if (options.mongoUrl) {\n      _clientP = MongoClient.connect(options.mongoUrl, options.mongoOptions)\n    } else if (options.clientPromise) {\n      _clientP = options.clientPromise\n    } else if (options.client) {\n      _clientP = Promise.resolve(options.client)\n    } else {\n      throw new Error('Cannot init client. Please provide correct options')\n    }\n    assert(!!_clientP, 'Client is null|undefined')\n    this.clientP = _clientP\n    this.options = options\n    this.collectionP = _clientP.then(async (con) => {\n      const collection = con\n        .db(options.dbName)\n        .collection<InternalSessionType>(options.collectionName)\n      await this.setAutoRemove(collection)\n      return collection\n    })\n    if (options.crypto.secret) {\n      this.crypto = require('kruptein')(options.crypto)\n    }\n  }\n\n  static create(options: ConnectMongoOptions): MongoStore {\n    return new MongoStore(options)\n  }\n\n  private setAutoRemove(\n    collection: Collection<InternalSessionType>\n  ): Promise<unknown> {\n    const removeQuery = () => ({\n      expires: {\n        $lt: new Date(),\n      },\n    })\n    switch (this.options.autoRemove) {\n      case 'native':\n        debug('Creating MongoDB TTL index')\n        return collection.createIndex(\n          { expires: 1 },\n          {\n            background: true,\n            expireAfterSeconds: 0,\n          }\n        )\n      case 'interval':\n        debug('create Timer to remove expired sessions')\n        this.timer = setInterval(\n          () =>\n            collection.deleteMany(removeQuery(), {\n              writeConcern: {\n                w: 0,\n                j: false,\n              },\n            }),\n          this.options.autoRemoveInterval * 1000 * 60\n        )\n        this.timer.unref()\n        return Promise.resolve()\n      case 'disabled':\n      default:\n        return Promise.resolve()\n    }\n  }\n\n  private computeStorageId(sessionId: string) {\n    if (\n      this.options.transformId &&\n      typeof this.options.transformId === 'function'\n    ) {\n      return this.options.transformId(sessionId)\n    }\n    return sessionId\n  }\n\n  /**\n   * promisify and bind the `this.crypto.get` function.\n   * Please check !!this.crypto === true before using this getter!\n   */\n  private get cryptoGet() {\n    if (!this.crypto) {\n      throw new Error('Check this.crypto before calling this.cryptoGet!')\n    }\n    return util.promisify(this.crypto.get).bind(this.crypto)\n  }\n\n  /**\n   * Decrypt given session data\n   * @param session session data to be decrypt. Mutate the input session.\n   */\n  private async decryptSession(\n    session: session.SessionData | undefined | null\n  ) {\n    if (this.crypto && session) {\n      const plaintext = await this.cryptoGet(\n        this.options.crypto.secret as string,\n        session.session\n      ).catch((err) => {\n        throw new Error(err)\n      })\n      // @ts-ignore\n      session.session = JSON.parse(plaintext)\n    }\n  }\n\n  /**\n   * Get a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n  get(\n    sid: string,\n    callback: (err: any, session?: session.SessionData | null) => void\n  ): void {\n    ;(async () => {\n      try {\n        debug(`MongoStore#get=${sid}`)\n        const collection = await this.collectionP\n        const session = await collection.findOne({\n          _id: this.computeStorageId(sid),\n          $or: [\n            { expires: { $exists: false } },\n            { expires: { $gt: new Date() } },\n          ],\n        })\n        if (this.crypto && session) {\n          await this.decryptSession(\n            session as unknown as session.SessionData\n          ).catch((err) => callback(err))\n        }\n        const s =\n          session && this.transformFunctions.unserialize(session.session)\n        if (this.options.touchAfter > 0 && session?.lastModified) {\n          s.lastModified = session.lastModified\n        }\n        this.emit('get', sid)\n        callback(null, s === undefined ? null : s)\n      } catch (error) {\n        callback(error)\n      }\n    })()\n  }\n\n  /**\n   * Upsert a session into the store given a session ID (sid) and session (session) object.\n   * @param sid session ID\n   * @param session session object\n   */\n  set(\n    sid: string,\n    session: session.SessionData,\n    callback: (err: any) => void = noop\n  ): void {\n    ;(async () => {\n      try {\n        debug(`MongoStore#set=${sid}`)\n        // Removing the lastModified prop from the session object before update\n        // @ts-ignore\n        if (this.options.touchAfter > 0 && session?.lastModified) {\n          // @ts-ignore\n          delete session.lastModified\n        }\n        const s: InternalSessionType = {\n          _id: this.computeStorageId(sid),\n          session: this.transformFunctions.serialize(session),\n        }\n        // Expire handling\n        if (session?.cookie?.expires) {\n          s.expires = new Date(session.cookie.expires)\n        } else {\n          // If there's no expiration date specified, it is\n          // browser-session cookie or there is no cookie at all,\n          // as per the connect docs.\n          //\n          // So we set the expiration to two-weeks from now\n          // - as is common practice in the industry (e.g Django) -\n          // or the default specified in the options.\n          s.expires = new Date(Date.now() + this.options.ttl * 1000)\n        }\n        // Last modify handling\n        if (this.options.touchAfter > 0) {\n          s.lastModified = new Date()\n        }\n        if (this.crypto) {\n          const cryptoSet = util.promisify(this.crypto.set).bind(this.crypto)\n          const data = await cryptoSet(\n            this.options.crypto.secret as string,\n            s.session\n          ).catch((err) => {\n            throw new Error(err)\n          })\n          s.session = data as unknown as session.SessionData\n        }\n        const collection = await this.collectionP\n        const rawResp = await collection.updateOne(\n          { _id: s._id },\n          { $set: s },\n          {\n            upsert: true,\n            writeConcern: this.options.writeOperationOptions,\n          }\n        )\n        if (rawResp.upsertedCount > 0) {\n          this.emit('create', sid)\n        } else {\n          this.emit('update', sid)\n        }\n        this.emit('set', sid)\n      } catch (error) {\n        return callback(error)\n      }\n      return callback(null)\n    })()\n  }\n\n  touch(\n    sid: string,\n    session: session.SessionData & { lastModified?: Date },\n    callback: (err: any) => void = noop\n  ): void {\n    ;(async () => {\n      try {\n        debug(`MongoStore#touch=${sid}`)\n        const updateFields: {\n          lastModified?: Date\n          expires?: Date\n          session?: session.SessionData\n        } = {}\n        const touchAfter = this.options.touchAfter * 1000\n        const lastModified = session.lastModified\n          ? session.lastModified.getTime()\n          : 0\n        const currentDate = new Date()\n\n        // If the given options has a touchAfter property, check if the\n        // current timestamp - lastModified timestamp is bigger than\n        // the specified, if it's not, don't touch the session\n        if (touchAfter > 0 && lastModified > 0) {\n          const timeElapsed = currentDate.getTime() - lastModified\n          if (timeElapsed < touchAfter) {\n            debug(`Skip touching session=${sid}`)\n            return callback(null)\n          }\n          updateFields.lastModified = currentDate\n        }\n\n        if (session?.cookie?.expires) {\n          updateFields.expires = new Date(session.cookie.expires)\n        } else {\n          updateFields.expires = new Date(Date.now() + this.options.ttl * 1000)\n        }\n        const collection = await this.collectionP\n        const rawResp = await collection.updateOne(\n          { _id: this.computeStorageId(sid) },\n          { $set: updateFields },\n          { writeConcern: this.options.writeOperationOptions }\n        )\n        if (rawResp.matchedCount === 0) {\n          return callback(new Error('Unable to find the session to touch'))\n        } else {\n          this.emit('touch', sid, session)\n          return callback(null)\n        }\n      } catch (error) {\n        return callback(error)\n      }\n    })()\n  }\n\n  /**\n   * Get all sessions in the store as an array\n   */\n  all(\n    callback: (\n      err: any,\n      obj?:\n        | session.SessionData[]\n        | { [sid: string]: session.SessionData }\n        | null\n    ) => void\n  ): void {\n    ;(async () => {\n      try {\n        debug('MongoStore#all()')\n        const collection = await this.collectionP\n        const sessions = collection.find({\n          $or: [\n            { expires: { $exists: false } },\n            { expires: { $gt: new Date() } },\n          ],\n        })\n        const results: session.SessionData[] = []\n        for await (const session of sessions) {\n          if (this.crypto && session) {\n            await this.decryptSession(session as unknown as session.SessionData)\n          }\n          results.push(this.transformFunctions.unserialize(session.session))\n        }\n        this.emit('all', results)\n        callback(null, results)\n      } catch (error) {\n        callback(error)\n      }\n    })()\n  }\n\n  /**\n   * Destroy/delete a session from the store given a session ID (sid)\n   * @param sid session ID\n   */\n  destroy(sid: string, callback: (err: any) => void = noop): void {\n    debug(`MongoStore#destroy=${sid}`)\n    this.collectionP\n      .then((colleciton) =>\n        colleciton.deleteOne(\n          { _id: this.computeStorageId(sid) },\n          { writeConcern: this.options.writeOperationOptions }\n        )\n      )\n      .then(() => {\n        this.emit('destroy', sid)\n        callback(null)\n      })\n      .catch((err) => callback(err))\n  }\n\n  /**\n   * Get the count of all sessions in the store\n   */\n  length(callback: (err: any, length: number) => void): void {\n    debug('MongoStore#length()')\n    this.collectionP\n      .then((collection) => collection.countDocuments())\n      .then((c) => callback(null, c))\n      // @ts-ignore\n      .catch((err) => callback(err))\n  }\n\n  /**\n   * Delete all sessions from the store.\n   */\n  clear(callback: (err: any) => void = noop): void {\n    debug('MongoStore#clear()')\n    this.collectionP\n      .then((collection) => collection.drop())\n      .then(() => callback(null))\n      .catch((err) => callback(err))\n  }\n\n  /**\n   * Close database connection\n   */\n  close(): Promise<void> {\n    debug('MongoStore#close()')\n    return this.clientP.then((c) => c.close())\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}