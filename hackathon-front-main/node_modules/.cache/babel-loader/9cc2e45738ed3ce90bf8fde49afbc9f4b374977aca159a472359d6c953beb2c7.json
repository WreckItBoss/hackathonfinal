{"ast":null,"code":"/*!\n * kruptein\n * Copyright(c) 2019 Jason Gerfen <jason.gerfen@gmail.com>\n * License: MIT\n */\n\"use strict\";\n\nclass Kruptein {\n  constructor(options) {\n    options = options || {};\n    this.crypto = require(\"crypto\");\n\n    // Set defaults if the user didn't supply any\n    this._algorithm = options.algorithm || \"aes-256-gcm\";\n    this._hashing = options.hashing || \"sha512\";\n    this._encodeas = options.encodeas || \"base64\";\n    this._use_asn1 = options.use_asn1 || true;\n\n    // Are we using AEAD mode (authenticated ciphers)?\n    this._aead_mode = this._algorithm.match(/ccm|gcm|ocb/) ? true : false;\n\n    // Set some defaults based on the algorithm used\n    let defaults = this._matrix(this._algorithm);\n    this._at_size = options._at_size || defaults._at_size;\n    this._iv_size = options._iv_size || defaults._iv_size;\n    this._key_size = options._key_size || defaults._key_size;\n\n    // Replace pbkdf2 with scrypt for key derivation?\n    this._use_scrypt = options.use_scrypt || false;\n\n    // Use asn.1 encoding?\n    if (this._use_asn1) {\n      this.asn1 = require(\"asn1.js\");\n      this.schema = this._schema();\n    }\n  }\n  set(secret, plaintext, aad, cb) {\n    // If non-aead cipher then expect 3 vs. 4 args\n    cb = cb || aad;\n\n    // Initialize some defaults\n    let iv, ct, hmac, obj, key;\n\n    // Bail if using weak cipher algorithm modes\n    if (this._validator()) return cb(\"Insecure cipher mode not supported!\");\n\n    // Bail if secret is not provided\n    if (!secret) return cb(\"Must supply a secret!\");\n\n    // Derive a stronger key from secret;\n    this._derive_key(secret, (err, secret) => {\n      if (err) return cb(\"Unable to derive key!\");\n      key = secret;\n    });\n\n    // Generate a random IV based on the algorithms IV size\n    iv = this._iv(this._iv_size);\n\n    // Are we dealing with an object?\n    let pt = plaintext;\n    try {\n      plaintext = Buffer.from(JSON.stringify(pt));\n    } catch (err) {\n      plaintext = Buffer.from(pt);\n    }\n\n    // If AEAD mode cipher used and an AAD not provided, create one\n    if (this._aead_mode && typeof aad === \"function\") {\n      this._digest(this._iv(128), plaintext, this._hashing, this._encodeas, (err, res) => {\n        if (err) return cb(\"Unable to generate AAD!\");\n        aad = res;\n      });\n    }\n\n    // Create ciphertext from plaintext with derived key\n    this._encrypt(key.key, plaintext, this._algorithm, this._encodeas, iv, aad, (err, ciphertext) => {\n      if (err) return cb(\"Unable to create ciphertext!\");\n      ct = ciphertext;\n    });\n\n    // Create an HMAC from the resulting ciphertext\n    this._digest(key.key, ct.ct, this._hashing, this._encodeas, (err, digest) => {\n      if (err) return cb(\"Unable to create digest!\");\n      hmac = digest;\n    });\n\n    // Create an object to pass back\n    obj = {\n      hmac: hmac,\n      ct: ct.ct,\n      iv: iv,\n      salt: key.salt\n    };\n\n    // If AEAD mode include the AAD\n    if (aad) obj.aad = aad;\n\n    // If AEAD mode include the AT\n    if (ct.at) obj.at = ct.at;\n\n    // Make sure the retured object is encoded property\n    return this._use_asn1 ? cb(null, this.schema.encode(obj).toString(this._encodeas)) : cb(null, JSON.stringify(obj));\n  }\n  get(secret, ciphertext, opts, cb) {\n    // If non-aead cipher then expect 3 vs. 4 args\n    cb = cb || opts;\n\n    // Initialize some defaults\n    let ct, hmac, pt, key;\n\n    // Bail if using weak cipher algorithm modes\n    if (this._validator()) return cb(\"Insecure cipher mode not supported!\");\n\n    // Bail if secret is not provided\n    if (!secret) return cb(\"Must supply a secret!\");\n\n    // Parse the provided ciphertext object or bail\n    try {\n      if (this._use_asn1) {\n        ct = this.schema.decode(Buffer.from(ciphertext, this._encodeas));\n        if (ct.at) ct.ct = ct.ct.toString();\n        if (ct.aad) ct.aad = ct.aad.toString();\n      } else {\n        ct = JSON.parse(ciphertext);\n      }\n    } catch (err) {\n      return cb(\"Unable to parse ciphertext object!\");\n    }\n\n    // Derive a stronger key from secret;\n    this._derive_key(secret, ct.salt, (err, secret) => {\n      if (err) return cb(\"Unable to derive key!\");\n      key = secret;\n    });\n\n    // Create an HMAC from the ciphertext HMAC value\n    this._digest(key.key, ct.ct, this._hashing, this._encodeas, (err, res) => {\n      if (err) cb(\"Unable to generate HMAC!\");\n      hmac = res;\n    });\n\n    // Compare computed from included & bail if not identical\n    if (hmac !== ct.hmac.toString()) return cb(\"Encrypted session was tampered with!\");\n\n    // If provided get the AAD &/or AT values\n    if (opts) {\n      ct.aad = opts.aad ? opts.aad : ct.aad ? ct.aad : false;\n      ct.at = opts.at && !ct.at ? opts.at : ct.at ? ct.at : false;\n    }\n\n    // Convert the AT to a buffer\n    if (ct.at) ct.at = Buffer.from(ct.at, this._encodeas);\n\n    // Create plaintext from ciphertext with derived key\n    this._decrypt(key.key, ct.ct, this._algorithm, this._encodeas, Buffer.from(ct.iv, this._encodeas), ct.at, ct.aad, (err, res) => {\n      if (err) return cb(\"Unable to decrypt ciphertext!\");\n      pt = res;\n    });\n    return cb(null, pt);\n  }\n  _encrypt(key, pt, algo, encodeas, iv, aad, cb) {\n    // If non-aead cipher then expect 6 vs. 7 args\n    cb = cb || aad;\n\n    // Initialize some defaults\n    let cipher, ct, at;\n\n    // Create a new cipher object using algorithm, derived key & iv\n    cipher = this.crypto.createCipheriv(algo, key, iv, {\n      authTagLength: this._at_size\n    });\n\n    // If an AEAD cipher is used & an AAD supplied, include it\n    if (this._aead_mode && typeof aad !== \"function\") {\n      try {\n        cipher.setAAD(Buffer.from(aad, encodeas), {\n          plaintextLength: Buffer.byteLength(pt)\n        });\n      } catch (err) {\n        return cb(\"Unable to set AAD!\");\n      }\n    }\n\n    // Add our plaintext; encode & pad the resulting cipher text\n    ct = cipher.update(Buffer.from(pt, encodeas), \"utf8\", encodeas);\n    cipher.setAutoPadding(true);\n    ct += cipher.final(encodeas);\n\n    // If an AEAD cipher is used, retrieve the authentication tag\n    if (this._aead_mode) {\n      try {\n        at = cipher.getAuthTag();\n      } catch (err) {\n        return cb(\"Unable to obtain authentication tag\");\n      }\n    }\n\n    // Return the object\n    return cb(null, at ? {\n      \"ct\": ct,\n      \"at\": at\n    } : {\n      \"ct\": ct\n    });\n  }\n  _decrypt(key, ct, algo, encodeas, iv, at, aad, cb) {\n    // If non-aead cipher then expect 6 vs. 7 args\n    cb = cb || aad;\n\n    // Initialize some defaults\n    let cipher, pt;\n\n    // Create a new de-cipher object using algorithm, derived key & iv\n    cipher = this.crypto.createDecipheriv(algo, key, iv, {\n      authTagLength: this._at_size\n    });\n\n    // If an AEAD cipher is used & an AT supplied, include it\n    if (this._aead_mode && at) {\n      try {\n        cipher.setAuthTag(Buffer.from(at, encodeas));\n      } catch (err) {\n        return cb(\"Unable to set authentication tag\");\n      }\n    }\n\n    // If an AEAD cipher is used & an AAD supplied, include it\n    if (this._aead_mode && typeof aad !== \"function\") {\n      try {\n        cipher.setAAD(Buffer.from(aad, encodeas), {\n          plaintextLength: ct.length\n        });\n      } catch (err) {\n        return cb(\"Unable to set additional authentication data\");\n      }\n    }\n\n    // Add our ciphertext & encode\n    try {\n      pt = cipher.update(ct.toString(), encodeas, \"utf8\");\n      pt += cipher.final(\"utf8\");\n    } catch (err) {\n      return cb(\"Unable to decrypt ciphertext!\");\n    }\n\n    // return the plaintext\n    return cb(null, pt);\n  }\n  _derive_key(secret, salt, cb) {\n    // If salt not supplied then expect 2 vs. 3 args\n    cb = cb || salt;\n\n    // Initialize some defaults\n    let key,\n      opts = {};\n\n    // If secret is an object then extract the parts; test harness only\n    if (typeof secret === \"object\") {\n      opts = secret.opts;\n      secret = secret.secret;\n    }\n\n    // If a salt was NOT supplied, create one\n    salt = typeof salt !== \"function\" ? Buffer.from(salt) : this.crypto.randomBytes(128);\n\n    // PBKDF2 or scrypt key derivation logic\n    try {\n      if (!this._use_scrypt || typeof this.crypto.scryptSync !== \"function\") {\n        key = this.crypto.pbkdf2Sync(secret, salt, 15000, this._key_size, this._hashing);\n      } else {\n        key = this.crypto.scryptSync(secret, salt, this._key_size, opts);\n      }\n    } catch (err) {\n      return cb(\"Unable to derive key!\");\n    }\n\n    // Return the derived key and salt\n    return cb(null, {\n      key: key,\n      salt: salt\n    });\n  }\n  _digest(key, obj, hashing, encodeas, cb) {\n    // Initialize some defaults\n    let hmac;\n\n    // Create an HMAC from the supplied data\n    try {\n      hmac = this.crypto.createHmac(hashing, key);\n      hmac.setEncoding(encodeas);\n      hmac.write(obj);\n      hmac.end();\n    } catch (err) {\n      return cb(\"Unable to generate digest!\");\n    }\n\n    // Return digest\n    return cb(null, hmac.read().toString(encodeas));\n  }\n  _iv(iv_size) {\n    return this.crypto.randomBytes(iv_size);\n  }\n  _matrix(algo) {\n    let obj = {\n      _at_size: 16,\n      _iv_size: 16,\n      _key_size: 32\n    };\n    if (algo.match(/ccm|ocb|gcm/i)) obj._iv_size = 12;\n    if (algo.match(/aes/) && algo.match(/128/)) obj._key_size = 16;\n    if (algo.match(/aes/) && algo.match(/192/)) obj._key_size = 24;\n    if (algo.match(/aes/) && algo.match(/xts/)) obj._key_size = 32;\n    if (algo.match(/aes/) && algo.match(/xts/) && algo.match(/256/)) obj._key_size = 64;\n    return obj;\n  }\n  _validator() {\n    return this._algorithm.match(/ccm|ecb|ocb2/);\n  }\n  _schema() {\n    let schema;\n    if (!this._aead_mode) {\n      schema = this.asn1.define('schema', function () {\n        this.seq().obj(this.key(\"ct\").octstr(), this.key(\"hmac\").octstr(), this.key(\"iv\").octstr(), this.key(\"salt\").octstr());\n      });\n    } else {\n      schema = this.asn1.define('schema', function () {\n        this.seq().obj(this.key(\"ct\").octstr(), this.key(\"hmac\").octstr(), this.key(\"iv\").octstr(), this.key(\"salt\").octstr(), this.key(\"at\").octstr(), this.key(\"aad\").octstr());\n      });\n    }\n    return schema;\n  }\n}\n\n// Robot, do work\nmodule.exports = function (options) {\n  return new Kruptein(options || {});\n};","map":{"version":3,"names":["Kruptein","constructor","options","crypto","require","_algorithm","algorithm","_hashing","hashing","_encodeas","encodeas","_use_asn1","use_asn1","_aead_mode","match","defaults","_matrix","_at_size","_iv_size","_key_size","_use_scrypt","use_scrypt","asn1","schema","_schema","set","secret","plaintext","aad","cb","iv","ct","hmac","obj","key","_validator","_derive_key","err","_iv","pt","Buffer","from","JSON","stringify","_digest","res","_encrypt","ciphertext","digest","salt","at","encode","toString","get","opts","decode","parse","_decrypt","algo","cipher","createCipheriv","authTagLength","setAAD","plaintextLength","byteLength","update","setAutoPadding","final","getAuthTag","createDecipheriv","setAuthTag","length","randomBytes","scryptSync","pbkdf2Sync","createHmac","setEncoding","write","end","read","iv_size","define","seq","octstr","module","exports"],"sources":["/Users/akamurasaki/hackathonfinal-1/hackathon-front-main/node_modules/kruptein/lib/kruptein.js"],"sourcesContent":["/*!\n * kruptein\n * Copyright(c) 2019 Jason Gerfen <jason.gerfen@gmail.com>\n * License: MIT\n */\n\"use strict\";\n\nclass Kruptein {\n\n  constructor(options) {\n    options = options || {};\n\n    this.crypto = require(\"crypto\");\n\n    // Set defaults if the user didn't supply any\n    this._algorithm = options.algorithm || \"aes-256-gcm\";\n    this._hashing = options.hashing || \"sha512\";\n    this._encodeas = options.encodeas || \"base64\";\n    this._use_asn1 = options.use_asn1 || true;\n\n    // Are we using AEAD mode (authenticated ciphers)?\n    this._aead_mode = this._algorithm.match(/ccm|gcm|ocb/) ? true : false;\n\n    // Set some defaults based on the algorithm used\n    let defaults = this._matrix(this._algorithm);\n    this._at_size = options._at_size || defaults._at_size;\n    this._iv_size = options._iv_size || defaults._iv_size;\n    this._key_size = options._key_size || defaults._key_size;\n\n    // Replace pbkdf2 with scrypt for key derivation?\n    this._use_scrypt = options.use_scrypt || false;\n\n    // Use asn.1 encoding?\n    if (this._use_asn1) {\n      this.asn1 = require(\"asn1.js\");\n      this.schema = this._schema();\n    }\n  }\n\n\n  set(secret, plaintext, aad, cb) {\n    // If non-aead cipher then expect 3 vs. 4 args\n    cb = cb || aad;\n\n    // Initialize some defaults\n    let iv, ct, hmac, obj, key;\n\n    // Bail if using weak cipher algorithm modes\n    if (this._validator())\n      return cb(\"Insecure cipher mode not supported!\");\n\n    // Bail if secret is not provided\n    if (!secret)\n      return cb(\"Must supply a secret!\");\n\n    // Derive a stronger key from secret;\n    this._derive_key(secret, (err, secret) => {\n      if (err)\n        return cb(\"Unable to derive key!\");\n\n      key = secret;\n    });\n\n    // Generate a random IV based on the algorithms IV size\n    iv = this._iv(this._iv_size);\n\n    // Are we dealing with an object?\n    let pt = plaintext;\n    try {\n      plaintext = Buffer.from(JSON.stringify(pt));\n    } catch(err) {\n      plaintext = Buffer.from(pt);\n    }\n\n    // If AEAD mode cipher used and an AAD not provided, create one\n    if (this._aead_mode && typeof aad === \"function\") {\n      this._digest(this._iv(128), plaintext, this._hashing, this._encodeas, (err, res) => {\n        if (err)\n          return cb(\"Unable to generate AAD!\");\n\n        aad = res;\n      });\n    }\n\n    // Create ciphertext from plaintext with derived key\n    this._encrypt(key.key, plaintext, this._algorithm, this._encodeas, iv, aad, (err, ciphertext) => {\n      if (err)\n        return cb(\"Unable to create ciphertext!\");\n\n      ct = ciphertext;\n    });\n\n    // Create an HMAC from the resulting ciphertext\n    this._digest(key.key, ct.ct, this._hashing, this._encodeas, (err, digest) => {\n      if (err)\n        return cb(\"Unable to create digest!\");\n\n      hmac = digest;\n    });\n\n    // Create an object to pass back\n    obj = {\n      hmac: hmac,\n      ct: ct.ct,\n      iv: iv,\n      salt: key.salt\n    };\n\n    // If AEAD mode include the AAD\n    if (aad)\n      obj.aad = aad;\n\n    // If AEAD mode include the AT\n    if (ct.at)\n      obj.at = ct.at;\n\n    // Make sure the retured object is encoded property\n    return (this._use_asn1) ?\n      cb(null, this.schema.encode(obj).toString(this._encodeas)) :\n      cb(null, JSON.stringify(obj));\n  }\n\n\n  get(secret, ciphertext, opts, cb) {\n    // If non-aead cipher then expect 3 vs. 4 args\n    cb = cb || opts;\n\n    // Initialize some defaults\n    let ct, hmac, pt, key;\n\n    // Bail if using weak cipher algorithm modes\n    if (this._validator())\n      return cb(\"Insecure cipher mode not supported!\");\n\n    // Bail if secret is not provided\n    if (!secret)\n      return cb(\"Must supply a secret!\");\n\n    // Parse the provided ciphertext object or bail\n    try {\n      if (this._use_asn1) {\n        ct = this.schema.decode(Buffer.from(ciphertext, this._encodeas));\n\n        if (ct.at)\n          ct.ct = ct.ct.toString();\n\n        if (ct.aad)\n          ct.aad = ct.aad.toString();\n      } else {\n        ct = JSON.parse(ciphertext);\n      }\n    } catch (err) {\n      return cb(\"Unable to parse ciphertext object!\");\n    }\n\n    // Derive a stronger key from secret;\n    this._derive_key(secret, ct.salt, (err, secret) => {\n      if (err)\n        return cb(\"Unable to derive key!\");\n\n      key = secret;\n    });\n\n    // Create an HMAC from the ciphertext HMAC value\n    this._digest(key.key, ct.ct, this._hashing, this._encodeas, (err, res) => {\n      if (err)\n        cb(\"Unable to generate HMAC!\");\n\n      hmac = res;\n    });\n\n\n    // Compare computed from included & bail if not identical\n    if (hmac !== ct.hmac.toString())\n      return cb(\"Encrypted session was tampered with!\");\n\n    // If provided get the AAD &/or AT values\n    if (opts) {\n      ct.aad = (opts.aad) ? opts.aad :\n        (ct.aad) ? ct.aad : false;\n\n      ct.at = (opts.at && !ct.at) ?\n        opts.at : (ct.at) ?\n        ct.at : false;\n    }\n\n    // Convert the AT to a buffer\n    if (ct.at)\n      ct.at = Buffer.from(ct.at, this._encodeas);\n\n    // Create plaintext from ciphertext with derived key\n    this._decrypt(key.key, ct.ct, this._algorithm, this._encodeas, Buffer.from(ct.iv, this._encodeas), ct.at, ct.aad, (err, res) => {\n      if (err)\n        return cb(\"Unable to decrypt ciphertext!\");\n\n      pt = res;\n    });\n\n    return cb(null, pt);\n  }\n\n  _encrypt(key, pt, algo, encodeas, iv, aad, cb) {\n    // If non-aead cipher then expect 6 vs. 7 args\n    cb = cb || aad;\n\n    // Initialize some defaults\n    let cipher, ct, at;\n\n    // Create a new cipher object using algorithm, derived key & iv\n    cipher = this.crypto.createCipheriv(algo, key, iv, {\n      authTagLength: this._at_size\n    });\n\n    // If an AEAD cipher is used & an AAD supplied, include it\n    if (this._aead_mode && typeof aad !== \"function\") {\n      try {\n        cipher.setAAD(Buffer.from(aad, encodeas), {\n          plaintextLength: Buffer.byteLength(pt)\n        });\n      } catch (err) {\n        return cb(\"Unable to set AAD!\");\n      }\n    }\n\n    // Add our plaintext; encode & pad the resulting cipher text\n    ct = cipher.update(Buffer.from(pt, encodeas), \"utf8\", encodeas);\n    cipher.setAutoPadding(true);\n    ct += cipher.final(encodeas);\n\n    // If an AEAD cipher is used, retrieve the authentication tag\n    if (this._aead_mode) {\n      try {\n        at = cipher.getAuthTag();\n      } catch (err) {\n        return cb(\"Unable to obtain authentication tag\");\n      }\n    }\n\n    // Return the object\n    return cb(null, (at) ? { \"ct\": ct, \"at\": at } : { \"ct\": ct });\n  }\n\n\n  _decrypt(key, ct, algo, encodeas, iv, at, aad, cb) {\n    // If non-aead cipher then expect 6 vs. 7 args\n    cb = cb || aad;\n\n    // Initialize some defaults\n    let cipher, pt;\n\n    // Create a new de-cipher object using algorithm, derived key & iv\n    cipher = this.crypto.createDecipheriv(algo, key, iv, {\n      authTagLength: this._at_size\n    });\n\n    // If an AEAD cipher is used & an AT supplied, include it\n    if (this._aead_mode && at) {\n      try {\n        cipher.setAuthTag(Buffer.from(at, encodeas));\n      } catch (err) {\n        return cb(\"Unable to set authentication tag\");\n      }\n    }\n\n    // If an AEAD cipher is used & an AAD supplied, include it\n    if (this._aead_mode && typeof aad !== \"function\") {\n      try {\n        cipher.setAAD(Buffer.from(aad, encodeas), {\n          plaintextLength: ct.length\n        });\n      } catch (err) {\n        return cb(\"Unable to set additional authentication data\");\n      }\n    }\n\n    // Add our ciphertext & encode\n    try {\n      pt = cipher.update(ct.toString(), encodeas, \"utf8\");\n      pt += cipher.final(\"utf8\");\n    } catch(err) {\n      return cb(\"Unable to decrypt ciphertext!\");\n    }\n\n    // return the plaintext\n    return cb(null, pt);\n  }\n\n\n  _derive_key(secret, salt, cb) {\n    // If salt not supplied then expect 2 vs. 3 args\n    cb = cb || salt;\n\n    // Initialize some defaults\n    let key, opts = {};\n\n    // If secret is an object then extract the parts; test harness only\n    if (typeof secret === \"object\") {\n      opts = secret.opts;\n      secret = secret.secret;\n    }\n\n    // If a salt was NOT supplied, create one\n    salt = (typeof salt !== \"function\") ?\n      Buffer.from(salt) : this.crypto.randomBytes(128);\n\n    // PBKDF2 or scrypt key derivation logic\n    try {\n      if (!this._use_scrypt || typeof this.crypto.scryptSync !== \"function\") {\n        key = this.crypto.pbkdf2Sync(secret, salt, 15000, this._key_size, this._hashing);\n      } else {\n        key = this.crypto.scryptSync(secret, salt, this._key_size, opts);\n      }\n    } catch (err) {\n      return cb(\"Unable to derive key!\");\n    }\n\n    // Return the derived key and salt\n    return cb(null, {\n      key: key,\n      salt: salt\n    });\n  }\n\n\n  _digest(key, obj, hashing, encodeas, cb) {\n\n    // Initialize some defaults\n    let hmac;\n\n    // Create an HMAC from the supplied data\n    try {\n      hmac = this.crypto.createHmac(hashing, key);\n      hmac.setEncoding(encodeas);\n      hmac.write(obj);\n      hmac.end();\n    } catch (err) {\n      return cb(\"Unable to generate digest!\");\n    }\n\n    // Return digest\n    return cb(null, hmac.read().toString(encodeas));\n  }\n\n\n  _iv(iv_size) {\n    return this.crypto.randomBytes(iv_size);\n  }\n\n\n  _matrix(algo) {\n    let obj = {\n      _at_size: 16,\n      _iv_size: 16,\n      _key_size: 32\n    };\n\n    if (algo.match(/ccm|ocb|gcm/i))\n      obj._iv_size = 12;\n\n    if (algo.match(/aes/) && algo.match(/128/))\n      obj._key_size = 16;\n\n    if (algo.match(/aes/) && algo.match(/192/))\n      obj._key_size = 24;\n\n    if (algo.match(/aes/) && algo.match(/xts/))\n      obj._key_size = 32;\n\n    if (algo.match(/aes/) && algo.match(/xts/) && algo.match(/256/))\n      obj._key_size = 64;\n\n    return obj;\n  }\n\n\n  _validator() {\n    return (this._algorithm.match(/ccm|ecb|ocb2/));\n  }\n\n\n  _schema() {\n    let schema;\n    if (!this._aead_mode) {\n\n      schema = this.asn1.define('schema', function() {\n        this.seq().obj(\n          this.key(\"ct\").octstr(),\n          this.key(\"hmac\").octstr(),\n          this.key(\"iv\").octstr(),\n          this.key(\"salt\").octstr()\n        );\n      });\n\n    } else {\n\n      schema = this.asn1.define('schema', function() {\n        this.seq().obj(\n          this.key(\"ct\").octstr(),\n          this.key(\"hmac\").octstr(),\n          this.key(\"iv\").octstr(),\n          this.key(\"salt\").octstr(),\n          this.key(\"at\").octstr(),\n          this.key(\"aad\").octstr()\n        );\n      });\n    }\n\n    return schema;\n  }\n}\n\n\n// Robot, do work\nmodule.exports = function(options) {\n  return new Kruptein(options || {});\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}